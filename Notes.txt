Variable :- It is the name of the reserved cell in the memory.

- Compile :- It is the process of find the error.
  Python also has a compiler, but it is still termed as a interpreter language.
  When a code is executed a .pyc file is created.

  Now suppose if you wrote a code and save a file like test.py

  Now to compile the file you can using the command :- 
  python -m py_complie test.py

  Here we can also use "py" in place of python i.e 
    py -m py_compile test.py
  Here -m is known as module name.
  

  This command will generate a file in "_pycache" folder and the extension of the file will be .pyc

When a code is compiled in "C" then it directly contacts the OS.

But in "Java" the compiled code is termed as Byte Code, and they create a concept of Virtual Machine (Programable Machine), So now first the code is converted into Byte Code, then it goes to JVM, and now we have to reach the OS, but as a machine can understand another machine more perfectly, so they created a JNI(Java Native Interface) so that the Byte Code is contacts the JNI then the JNI contact the OS. JNI contains some interfaces that helps the OS to understand the code.

Now in python we PVM(Python Virtual Machine) and it also implements some methods from the JNI and in python the JNI name is not changed.

The working od JNI is like, when we try to execute a code the code is provided to JNI, it uses it method to interpret the code and then give the OS the revised code.


- Byte Code :- It is a special type of code. It contains special types of symbols and characters. Each symbol or Character to take one byte to store itself in memory. This is the reason why it is called Byte Code.

Modulo 3 :- Ended in 2010. Python also have some features of the modulo 3 language.

Suppose you wrote a code :-

import dis
print("hello")

py -m dis test.py (Use this code on CMD)

Using the above command we can get the machine code or the backend code.

Python Identifiers :- Identifier is a object which identify what it is.Identifier can also be termed as names. It can be a variable name, function name, class name, etc. 

Rules for Identifiers :- 
1. We can define an identifier with a single character or multiple characters too. Eg :- a = 10 ; A = 20 ; _ = 100
2. Identifiers should not start with a digit but can end with a digit. Eg :- A32 = 1 ; a21 = 3.14
3. Python identifiers are case sensitive. Eg :- a = 10 and A = 20 so a != A.
4. No length limit of identifiers in python.
5. We can not use reserved keywords as identifiers. 

Reserved Keywords :- There are 51 keywords in Java and there are 34 ke

Reserved Words= ['True', 'False', 'None', 'and', 'or', 'not', 'is', 'if', 'elif', 'else', 'while', 'for', 'break', 'continue', 'return', 'int', 'yield', 'try', 'except', 'finally', 'raise', 'assert', 'import', 'from', 'as', 'class', 'def', 'pass', 'global', 'nonlocal', 'lambda', 'del', 'with', 'async', 'await']

All 35 keywords always start with small alphabets but "True", "False", "None" start with capital letter.

Switch concept is not allowed in python.

Do While is not allowed in python.

When we use single quotes, when we use double quotes or triple single quotes. For single line content we use single and double quotes. For multi line content we triple single quotes.
Eg :-
  x = 'Hi'
  a = """This class is for python students only, to use '@' and '!' as normal character to define doc string"""
  @ is "at".
  
Note :-  Supppose you have to define a variable as public, protected and private. So that how we can do it :- 

"x" = Public
"_x" = Protected
"__x" = Private

Note :- There is no char datatype in python, here we only use str()

Index :- In python we can traverse the a array, from right to left and left to right, in both the directions.
         So if you have a array :
         a = [10,20,30,40] 
         So to access the last element we can write a[-1] and for the first element we can write a[0].

Arrays :- Array is a contigious memory structure. Suppose you have a memory in structure of 6 * 3 matrix and you have stored the value as a = [1,2,3,4,5,6,7,8,9,10,12] so when we reach the 6th memory address if the memory is not contigious then after the 6th address we will reach 1st address, if that's the case this means the memory is continous not contigious. So if we have to make a continous memory a contigious memory, we have to give a single address to each reserved cell seperately so this will make the memory contigious.

  Multi-Dimenisional array :- They are knows as the arrays of arrays. So suppose you want to create a 3 * 2 array, so first create a 1-D array and now create 3 1-D array now we have to store the address of the this 3 1-D arrays at the index [0,1,2] and now the 2-D array of 3 * 2 is created.

Primitive and Non-Primitive data types :- 
  1. Primitive :- There are many types.
                  a. Boolean
                  b. Integer 
                  c. Character
                  // Integer and Character comes under the sub type of Numeric
  2. Non-Primitive :- The size of all the non-primitive data types are always 4 bytes.
                      There are many types.
                      a. Class
                      b. Interfaces
                      c. String
                      d. Array
                      e. Structure
                      f. etc.

Object and classes :- So let's try to take an example of an object from Java.;
  Eg :- Test t = new Test(); //So here the size of t is 4 bytes.
    So here the test is the class and "t" is the reference of the class. We can also say that "test" is the data type of "t". When we write the command "new Test()", this generates a hexadecimal value in the memory and the system treats this hexadecimal value as the integer value that's why the size of "t" is 4 bytes.

 Suppose you have a variable "a", then if you want to check what data type is the variable then you can use :- print(type(a))
 Similarly if we can use print(id(a)), to get a hexadecimal value of the reserved cell reference id, which is use to access the value.

What is Immutability in python?

Object reusablity concept is only for "int", "float", "bool" and "
str", not for complex (complex variables are immutable) . The main use of imputability in python is utilization of memory.
So suppose you have two variables a and b, now:
  a = 10
  b = 10
  print(a is b)
  print(id(a), id(b))
  So now in the above code a reserved cell is created to store the value 10 and when the variable a is referencing to the value 10 and after that b is also referencing the value 10 then, we should create 2 reserved cell for each variable but in python we create a single reserved for the variable a and when b is also refering to the same value so in place of creating a new reserved cell, we refer both the variable to the same address.

Prove that the list is mutable or immutable or not ?
Ans. Suppose you have :-
      my_list = [10, 20, 30, 40]
      print(id(my_list)) # Output :- <class 'list'>
      # Here my_list is the reference variable for the class object.
      All fundamental data types are immutable, but is mutable object. In the existing object, you can perform any changes.

Proof of mutablity of the list: - 
  my_list = [10, 20, 30, 40, 50]
  my_list[1] = 70 # It will replace the value of the index 1.
  print(my_list) # Output: [10, 70, 30, 40, 50]
  

Collection Data types: -

So if we want to hold a group of values as single entity, then we will go for collection related data types. 

There are 8 collection related data types: -
  1. List
  2. Tuple
  3. Set
  4. Dictionary
  5. Frozen set 
  6. Byte array
  7, Bytes
  8. range

1. List :- It is a sequence of value or order. If we want to reperesent a group of values or object as a single entity where duplicate values are allowed and the order is mandatory (i.e it preserves the order of insertion). We can access the list items using list. 

Some points about list: -
  1. Insertion order preserved.
  2. Duplicate object are allowed.(Each element in the list is in the form of the object)
  3. Indexing and Slicing are applicable.
  4. Mutable
  5. It is growable in nature.
  6. Heterogenous object are allowed. Eg: list = ['PA', [8, 7], [9, 9], [7, 4], [9, 7], {'Kamehameha', 'Rasengun'}]
  . There is a method named append, it is use to insert the value at the end of the list. 
  Eg: lst = [10, 02, 30, 40]
      lst.append(23)
      # or lst.insert(len(lst), 23)

Eg: -

a = 10,20,30
print(a) # Output: (10, 20, 30)
print(a[0]) # Output: 10
print(type(a)) # Output: <class 'tuple'>

Docstring: - It provides a 

List comprehension:- 

Eg:- list = [10,20,30,40]
     list = [10 if x == 10 else (20 if x == 20 else x) for x in list]
Here the "in" keyword is returning the boolean value.

Tuple :- To create a tuple we have to use "()" . It is exactly same as list, only the reperesentation is same. The only difference is that it is immutable. It means that it is only available as the read only version. We use the tuple data types if and only if the data once input must not be changed in future.

Eg :- t = (10, 20, 30, 40)
      print(t)
      # the append and remove method are not applicable in a tuple.

Proof that the tuple is immutable:-

If we pass any type of single value in a tuple, so always use the single value followed by a comma.

Eg:- t = (10,)
     print(t[0])

     #on the older version of python if we have a tuple with single element then 

Enumerate :- This function return a tuple containing a count of every iteration (from start default is zero) and the values obtained from iterating over a sequence.

Set :- Whenever we want to create a dataset with no duplicate values then we can use a set. If we want to represent a group of enteries in which duplicates are not allowed and order not required.

Properties :- 
1. Duplicates are not allowed.
2. Order is not mandatory.
3. Indexing and slicing not applicable.
4. Heterogenous objects are allowed.
5. Set is growable.
6. Append method is not applicable on a set.
7. Set elements are immutable.
8. Set does not allow mutable items.

When we are adding a element in a set a mathematical formula is applied on the element to find the index of the element.

Eg:- my_set = {} # Here python treats this as a dictionary.

Dictionary :- 
1. It is mutable. 
2. It has key value to fetch the data. 
3. There does not exist two values with same key. 
4. The order is not important in Dict. 
5. So as we know that duplicate keys are not allowed, but duplicate values are allowed. 
6. If a key exist corresponding to a value, then we can update the value corresponding to the key. 
7. Heterogenous elements can be stored. Indexing and slicing not allowed.

Why dict() function creates an set where as it is possible to create a empty set using data type?

Eg: - {1 : 10, 2 : 20, 3 : 30, 4 : 40}

Functions: - Function has a prototype. Prototype means modifiable. The Prototype of a function have 5 things: -
1. Access Specifier
2. Access Modifier
3. Return type
4. Name
5. Arguments

Eg: - public static void main(String [] args)
Here,  
Public :- Access Specifier
Static :- Access Modifier
void :- return type
main :- Name
String[] args :- Arguments

In python the "def" contains the whole prototype of a function.

Object:- It is a thing that has some property and behaviour. Here the properties means the data members of the class and behaviour means the member function of a class.

Function: - It is always independent of anything.

Method: - It is always dependent on anything.

Class: - It is nothing but a container of similar types of objects. We can also term the class as the implementation of an object.
 
__init__ () :- It is used for the initialization of an object. If it is run according to a class it will instantiates the class and vice versa for an object too.

At the time of an object creation those properties of the object are initialized at that moment. That's why say that, Object is an instance of an class.

Suppose a code:-

class Employee:
    def __init__(self, name, emp_id):
        self.name = name
        self.emp_id = emp_id

name = input("Enter employee name: ")
emp_id = input("Enter employee ID: ")
emp = Employee(name, emp_id)

print(f"Employee Name: {emp.name}, Employee ID: {emp.emp_id}")

In python/Java the "." operator is known as the association operator.

When we use self.name or anything with the self keyword than this process is known as "Data Shadowing". We use the self keyword when the variable name of local and instance is same. It is similar to this keyword from java.

Inheritance :- Implementing an Object using an existing object.

1. __init__ is a special type of method that is working automatically as soon as the object of that class is created.

2. Python only supports the method overloading, and when a language supports method overloading.

Overloading: - Overloading refers to the ability for functions or operators to behave differently depending on the input parameters.

Inheritance: -Inheritance is a mechanism in which one class acquires the properties and behaviors of another class.

What is Constructer in Python?
A Constructer is nothing but a set of method. 
Non-parameterised Constructer: - def __init__(self):

A Non-parameterised constructer cannot return any value other than None.

Python won't support method/constructer overloading because of type concept are not available (Dynamically Typed) but how we can see only.

Eg:- 
def m1(i):
  print(i)

m1(10)
m1('Hello')
m1(20.36)

Polymorphism:- One name many forms.
Eg: - 
Let's take an example, suppose i man name Gopal, for his mother he is her son, for her sister he is her brother, for his friend he is someone else.

Eg: - 
def show(self):
  ....

def show(self, val):
  ....

def show(self, val1, val2):
  ....


Compile Time binding: - So when ever it is static then the memory is allocated for that static before the object is formed.

Python supports several types of arguments:

1. Positional Aguments:- These are the most common arguments, where the arguments value is based on its position.
Eg: - In func(a, b). a and b are the positional arguments.
2. Keyword Arguments:- The paramete name identifies these and can be supplied in any order, making your code more readable.
Eg: - For instance, func(a = 1, b = 2) explicitly states which parameter each argument corresponds to.

3. Default arguments:- A parameter with a default value can be qomitted in a function call. The function will then use the default value..

4. Varilable-length Arguments:- You may need to determine the number of arguments supplied to your function.

Python allows you to handle this with variable length arguments and defined with an asterisk *args and **kwargs.

#Example:-

def name(title, name, greeting="Hello"):
  return f"{greeting} {title} {name}!"

# positional arguments
print(name("Dr", "Smith"))

# Keyword Arguments
print(name(name = "Smith", title = "Prof"))

# Default Arguments
print(name("Mr", "Brown"))

# All combined
print(name("Mr", "Brown", greeting="Good Morning"))


Abstraction: - It means to show the functionality and hide the complexity.

Types of Variable:-
1. Instance Variable: - Instance variable is a variable which is declared inside the method and belongs to the object.

2. Static Variable: - Static variables are variables that are common to all instances of a class. They are defined within a class but outside any of the class's methods.

3. Local Variable: - A local variable is a variable that is declared inside a function or block and can only be accessed within that function or block. When the function or block is exited, the local variable goes out of scope and is no longer accessible.

Where can we define a instance variable?

1. Inside Constructer(def __init__)
2. Inside instance method.(An instance method in object-oriented programming is a method that is associated with an instance of a class. It operates on the instance's data and can modify its state)
3. Outside of class by using reference variable.
  3.1 If you are adding any instance variable for an object outside of the class those instance variable are available only for that particular object not for the remaining object, so we can call from outside the class.

class Test:
  def __init__(self):
    self.a = 10
    self.b = 20

  def m1(self):
    self.c = 30
    self.d = 40

t1 = Test()
print(t1.__dict__)
t2 = Test()
print(t2.__dict__)
t1.m1()
t2.m1()
print("After calling instance method m1(): ", t2.__dict__)
t1.c = 300
print("After calling instance method m1(): ", t1.__dict__)


Note: - In python there does not exist any compile time eof the program.

An unwanted, unexpected event that disturbs your normal flow of the program is by default consider as an execption or error.

There are two types of execption:-
  1. Built-in 
  2. User-Defined

Eg:-
  1. InternetError
  2. SleepingError
  3. FileNotFoundError
  4. ZeroDivisionError
  5. ValueError

Q. What is the main objective of exception handling?
Ans.
  1. It is highly recommnedation to handle the exception.
  2. The main objective of execption hanlding is gracefull/normal termination of the application(i.e. we should not block out resources and we should not miss anything).

Execption handling doese not means repairing an execption. We have to define alternative way to continue rest of the program normally.

Eg:-

import sys

randomlist = ['a', 0, 1, 7]
for entry in randomlist:
  try:
    print(entry)
    print("The entry is: ", entry)
    r = 1/int(entry)
    break
  except:
    print("Oops!", sys.exc_info()[0], "occured.") # Here we can use 0 index for the exception type and 1 index for the exception value and 2 index for the traceback
    print("Next entry.")
    print()
print("The reciprocal of", entry, "is", r)
